<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>找到具有最大和的连续子数组 | 柠檬小小</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><header class="wrapper header"><div class="container blog-title"><a class="title" id="logo" href="/.">柠檬小小</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><input id="menu" type="checkbox"><div class="container nav-items"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></div></header><article class="wrapper"><div class="post-entry"><div class="post"><div class="container post-header"><h1>找到具有最大和的连续子数组</h1></div><div class="container post-content"><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<a id="more"></a>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h6><p>通常我们遍历子串或者子序列有三种遍历方式：[a, b , c, d , e]</p>
<ul>
<li>以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]。</li>
<li>根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。</li>
<li>以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。</li>
</ul>
<h6 id="Kadane算法"><a href="#Kadane算法" class="headerlink" title="Kadane算法:"></a>Kadane算法:</h6><ul>
<li>Kadane算法扫描一次整个数列的所有数值，</li>
<li>在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。</li>
<li>该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。</li>
<li>因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出,</li>
<li>该算法可看成动态规划的一个例子。</li>
<li>状态转移方程：sum[i] = max{sum[i-1]+a[i],a[i]}   </li>
<li>其中(sum[i]记录以a[i]为子序列末端的最大序子列连续和)</li>
</ul>
<h6 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function  maxSubArray2  ( nums ) &#123;</span><br><span class="line">    if (!nums.length) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let max_ending_here = nums[0];</span><br><span class="line">    let max_so_far = nums[0];</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; nums.length; i ++ ) &#123;</span><br><span class="line">        max_ending_here = Math.max ( nums[i], max_ending_here + nums[i]);</span><br><span class="line">        max_so_far = Math.max ( max_so_far, max_ending_here);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return max_so_far;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var maxSubArray = function(nums) &#123;</span><br><span class="line">    let ans = nums[0];</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for(let num of nums) &#123;</span><br><span class="line">        if(sum + num &gt; num )&#123;</span><br><span class="line">            sum = sum + num;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, sum);</span><br><span class="line">    &#125;;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>使用动态规划方法解题有较高的时间效率，关键在于它减少了很多不必要的计算和重复计算的部分</p>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/</a><br>来源：力扣（LeetCode）</p>
</div></div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>